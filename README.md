# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
## Типы данных, используемых в проекте
### *Типы данных для взаимодействия с сервером*  
Карточки, получаемые с сервера
```
interface ICard {
    _id: string;
    title: string;
    price: number | null;
    category: string;
    image: string;
    description: string;
}
```
Каталог карточек 
```
export interface ICardsCatalog {
    cards: ICard[];
    selectedCard: string | null;
    getCard(cardId: string): ICard;
}
```
Данные о пользователе, кототрые пойдут на сервер в POST-запросе
```
interface IUser {
    payment: string;
    address: string;
    email: string;
    phone: string;
    total: number;
    items: string[];
}
```
Для работы с данными пользователя
```
interface IUserData {
    setUserInfo(userInfo: TUserPayAddress | TUserContact | TUserBasket): void;
    getUserBasket(): TUserBasket;
    checkUserValidation(data: TUserBasket | TUserPayAddress | TUserContact): boolean;
}
```

В ответ на POST-запрос с сервера будет приходить объект с информацией о заказе
```
interface IOrderResult {
    id: string; //id заказа
    total: number; //общая стоимость заказа
}
```
*Типы данных, которые понадобятся в коде, но не используют полную информацию из интерфейсов выше*  

Данные о товаре для отображения в корзине
```
type TCardBasket = Pick<ICard, '_id' | 'title' | 'price'>;
```
Данные о пользователе, получаемые с формы "Способ оплаты / адрес"
```
type TUserPayAddress = Pick<IUser, 'payment' | 'address'>;
```
Данные о пользователе, получаемые с формы "Почта / телефон"
```
type TUserContact = Pick<IUser, 'email' | 'phone'>;
```
Данные, которые понадобятся при работе с корзиной
```
interface IBasket {
    products: TCardBasket[];
    addProductToBasket(productId: string): void;
    deleteProductFromBasket(productId: string): void;
}
```
Объект для хранения сообщений об ошибках по полям заказа
```
export type FormErrors = Partial<Record<keyof IUser, string>>;
```

## Архитектура приложения
Код приложения будет разделен на 3 базовых слоя в соответствии с MVP-подходом:
- отображение, слой для выведение данных на страницу и взаимодействия с пользователем;
- модель, слой для хранения данных и их изменения при необходимости;
- презентер, слой, осуществляющий связь слоев отображения и модели.

### Базовый код
Наряду с классами для создания экземпляров карточек, данных пользователя и других в проекте будут использованы классы, реализующие стандартную логику взаимодействия с сервером (класс `Api`) и создание и работу брокера событий (класс `EventEmitter`).
#### Класс Api
Класс позволяет получить экземпляр объекта, в котором будут доступны методы для формирования GET- и POST-запросов к серверу, предусмотрена возможность расширения и формирования PUT- и DELETE-запросов. При создании экземпляра класса необходимо передать базовый URL, по которому расположен сервер, также опционально можно передать объект для дополнения заголовков запроса. Получаемый экземпляр будет обладать 2 методами:
- `get` метод отправляет GET-запрос на адрес, формируемый с помощью эндпоинта, передаваемого методу в качестве аргумента, возвращает промис с объектом, пришедшем как ответ от сервера;
- `post` метод отправляет POST-запрос на сервер, при вызове метода нужно передать эндпоинт (куда отправлять) первым аргументом и объект с данными вторым аргументом. Метод можно изменить так, чтобы он отправлял PUT- или DELETE-запросы, передав соответствующий метод третьим аргументом. В результате работы метода также вернется промис с объектом ответа от сервера.

#### Класс EventEmitter
Представляет собой классическую реализацию брокера событий. Класс имплементирует интерфейс *IEvents*, который требует, чтобы в классе присутствовали методы *on*, *emit* и *trigger* Позволяет подписываться на событие или отписываться от него, также возможно генерировать события. Для работы с событиями используется поле, в котором хранится объект, ключами которого служат названия событий, а значениями - уникальные экземпляры объектов, подписавшихся на соответствующее событие. Класс помогает в реализации работы презентера. Методы:
- `on` и `off` - подписаться или отписаться от события
- `emit` - метод для инициализации события
- `trigger` - метод, возвращающий функцию, которую можно использовать для генерации события
- `onAll` и `offAll` - методы, позволяющие подписаться или отписаться от всех событий, в данном коде использованы не будут

### Слой модели
#### Класс CardsData
Класс будет использован для хранения и работы с информацией о карточках товаров. Для реализации корректной работы по получению данных в одном из полей класса будет предусмотрено хранения экземпляра класса EventEmitter. В классе будут присутствовать следующие поля:
- `_cards: ICard[];` приватное поле для хранения списка товаров, которые будут получены с сервера, в классе будет предусмотрен геттер для получения значений из этого поля для отображения на странице
- `_selectedCard: string | null;` приватное поле для хранения id выбранной карточки товара, в классе будут предусмотрены сеттеры и гетеры для записи и получения id выбранной карточки

и методы:
- `getCard(cardId: string): ICard;` метод для получения конкретной карточки по ее id

Поля в классе будут защищенными, так как эти данные не должны быть доступны пользователю.
#### Класс UserData
Класс будет использован для хранения и работы с данными текущего пользователя. Аналогично классу CardsData в одном из полей класса будет предусмотрено хранения экземпляра класса EventEmitter. В классе будут присутствовать следующие поля:
- `payment: TPayMethod;` поле для хранения способа оплаты заказа
- `address: string;` поле для хранения адреса
- `email: string;` поле для хранения почты пользователя
- `phone: string;` поле для хранения номера телефона пользователя
- `_total: number;` поле для хранения информации об общей стоимости корзины, в классе будут предусмотрены геттеры и сеттеры для работы со значением поля
- `_items: string[];` поле для хранения массива id выбранных пользователем товаров, в классе будут предусмотрены геттеры и сеттеры для работы со значением поля

и методы:
- `setUserInfo(userInfo: IUser): void;` метод для сохранения информации о пользователе, будет использоваться при оформлении заказа
- `getUserBasket(): TUserBasket` метод для получения информации о товарах, добавленных пользователем в корзину
- `addProductToBasket(productId: string): void;` метод для добавления товара по id в корзину
- `deleteProductFromBasket(productId: string): void;` метод для удаления товара по id из корзины
- `checkUserValidation(data: TUserBasket | TUserPayAddress | TUserContact): boolean;` метод для проверки корректности введенных данных, будет испоьзоваться при оформлении заказа перед отправкой данных на сервер
- `clearUserBasket(): void` метод для очистки всей корзины после отправки данных на сервер

### Слой отображения
Можно выделить ряд компонентов, которые будут ответственны за отображение приложения в различных состояниях, для каждого из них будет создан свой класс.
#### Класс Page
Класс будет ответственен за отрисовку главной страницы сайта, например, при первичной загрузке. Классу потребуются поля для хранения HTML-элементов:
- `container: HTMLElement;` будет хранить элемент-родитель для всех остальных элементов, в контексте проектной подразумевается, что это будет `<body class="page">`
- `protected _gallery: HTMLElement;` будет хранить элемент родительского контейнера для списка карточек товаров на главной странице
- `protected _basketButton: HTMLElement;` будет хранить элемент, отображающий корзинку на главной странице. В конструкторе класса будет предусмотрена установка слушателя клика на кнопку корзинки
- `protected _counter: HTMLElement;` будет хранить элемент, в котором будет отображаться счетчик корзины, который будет хранить число товаров в корзине
- `protected _wrapper: HTMLElement;` будет хранить элемент, в который обернута вся страница внутри body, может потребоваться, чтобы заблокировать действия со страницей при открытом попапе
- чтобы иметь возможность работать с событиями на странице также можно предусмотреть передачу в конструктор значения для поля `events: IEvents`

В классе будет реализовано 3 сеттера для полей: 
- `counter: number` - значение, устанавливаемое в поле, будет использовано для отображения в элементе, хранящемся в _counter
- `gallery: HTMLElement[]` - в контексте проектной этому свойству будет присваиваться массив HTML-элементов, каждый из которых является карточкой товара
- `locked: boolean` - при установке истинного значения страница будет блокироваться для скролла, при установке ложного - становится доступной

#### Класс Card
Класс потребуется для настройки отображения карточки. Будет учтено, что карточка может отображаться как кнопка на главной странице, как карточка товара в попапе и как элемент списка в корзине. В силу разного отображения карточки некоторые из полей класса, которые предназначены для хранения HTML-элементов, будут опциональными. Поля класса:
- `container: HTMLElement;` будет хранить элемент-родитель для всех остальных элементов, в контексте проектной подразумевается, что это будут контейнеры с классами *gallery__item* для карточек на главной странице, *card_compact* для карточек в корзине и *card_full* для карточек в попапе
- `protected _title: HTMLElement;` будет хранить элемент для отображения заголовка карточки, используется во всех вариантах отображения
- `protected _price: HTMLElement;` будет хранить элемент для отображения стоимости товара, используется во всех вариантах отображения
- `protected _image?: HTMLImageElement;` будет хранить элемент для отображения картинки товара в карточке (для отображения карточки в корзине не нужно)
- `protected _category?: HTMLElement;` будет хранить элемент для отображения заголовка типа товара (для отображения карточки в корзине не нужно)
- `protected _description?: HTMLElement;` будет хранить элемент для отображения описания товара (для отображения карточки в корзине не нужно)
- `protected _button?: HTMLButtonElement;` будет хранить элемент кнопки, связанной с карточкой, по нажатии на которую будет что-то происходить (для карточки в попапе это кнопка "В корзину", для карточки в корзине - иконка удаления). В конструкторе класса будет предусмотрена установка слушателя клика на кнопку (или на всю карточку в случае с главной страницей)
- `protected _basketItem?: HTMLElement;` будет хранить элемент, в котором будет отображаться номер товара в списке в корзине
- допустим, что в конструктор класса можно будет опционально передавать объект каких-то дейтсвий с карточкой: `actions?: {onClick: (event: MouseEvent) => void;}`

В классе будут реализованы сеттеры для полей: 
- `title: string` - значение, устанавливаемое в поле, будет использовано для отображения названия карточки товара
- `price: number | null` - значение, устанавливаемое в поле, будет использовано для отображения стоимости товара
- `description?: string` - значение, устанавливаемое в поле, будет использовано для отображения описания товара в попапе карточки и в карточке на главной странице
- `image?: string` - значение, устанавливаемое в поле, будет использовано для отображения картинки товара в попапе карточки и в карточке на главной странице
- `category?: string` - значение, устанавливаемое в поле, будет использовано для отображения типа товара в попапе карточки и в карточке на главной странице
- `id: string` - значение, устанавливаемое в поле, будет использовано для создания дата-атрибута для хранения информации об id карточки
- `basketItem?: number` будет использован для установки номера товара в списке в корзине в соответствующем поле

Также в классе будут предусмотрены геттеры для полей: `title`, `price` и `id`.

Методы класса:
- `setCardButtonText(textContent: string):void` может менять текст на кнопке в модальном окне товара в зависимости от стоимости товара или его наличия в корзине
- `getCardButtonText():string` получает значение текста на кнопке в модальном окне товара, отталкиваясь от пользовательского интерфейса будем говорить, что делать при клике на кнопку: добавлять товар в корзину или удалять его
- `disableCardButton():void` делает кнопку в модальном окне товара недоступной для нажатия, чтобы было невозможно добавить в корзину "бесценные" товары

#### Класс Modal
На странице будет много модальных окон с различной информацией, у всех модальных окон должен быть одинаковый механизм их открытия и закрытия. Можно избежать дублирования кода и создать класс, который будет отвечать за показ модального окна, а содержимое этого модального окна формировать в других классах. В конструктор такого метода должен будет передаваться элемент-контейнер, по верстке это должен быть элемент с классом modal__container, а также объект событий, так как модальное окно должно уметь создавать какие-то события в ответ на действия пользователя. Еще в классе будут поля:
- `protected _closeButton: HTMLButtonElement;` будет хранить элемент кнопки закрытия модального окна, на ней будет предусмотрен слушатель клика, вызывающий закрытие модального окна
- `protected _content: HTMLElement;` будет хранить элемент-контейнер для контента попапа, это может быть форма, корзина, подробная информация о товаре или подтверждение оформления заказа
- `container: HTMLElement` и `events: IEvents` их значения будут передаваться в конструкторе

Методы, которые должны быть у любого модального окна:
- `open(): void` и `close(): void` для открытия или закрытия модального окна
- `render(data: {content: HTMLElement;}): HTMLElement` для рендера модального окна с уже нужным содержимым
- в классе будет предусмотрен сеттер для поля `content(value: HTMLElement)`, чтобы в элемент контента можно было добавить содержимое.

В модальном окне может отображаться карточка товаров, что будет предусмотрено в классе карточки, а также корзина, формы, в которых пользователь должен будет заполнить информацию для оформления заказа, и уведомление, что заказ был оформлен. Для отображения этой информации потребуются классы формы, корзины и блока подтверждения.

#### Класс Form<T>
Класс будет отвечать за отрисовку форм в модальных окнах, формировать события в ответ на действия пользователя, выводить сообщения об ошибках, если какие-то из полей будут заполнены некорректно, и блокировать кнопку отправки формы, если в ней есть ошибки или пустые поля. Дженерик в классе понадобится, чтобы можно было работать с разными формам. В конструктор класса должен будет передаваться элемент контейнера, элемент формы, а также объект событий (в поля `container: HTMLFormElement` и `events: IEvents`). В конструкторе будет предусмотрен слушатель на отправку формы и слушатель на внесение каких-то данных в поля ввода. Другие поля класса:
- `protected _submit: HTMLButtonElement` будет хранить элемент кнопки отправки формы
- `protected _paymentButton?: HTMLButtonElement[]` будет хранить элементы кнопок выбора способа оплаты в одной из форм, в зависимости от того, на какой из них будет срабатывать клик, будет устанавливаться значение в поле _payment?
- `protected _errors: HTMLElement` будет хранить элемент, в котором будет отображаться текст ошибки, если форма заполнена неверно
- `_payment?: TPayMethod` будет хранить способ оплаты, выбранный пользователем в одной из форм, значение в поле будет устанавливаться с помощью сеттера в зависимости от кликнутой кнопки.
- `valid: boolean` и `errors: string[]` поля для отработки того, что делать с формой, если есть ошибки заполнения. Значения полей будут устанавливаться через сеттеры, в результате которых кнопка отправки может становиться доступной или нет, а также появляться сообщение об ошибке

Методы класса:
- `onInputChange(field: keyof T, value: string)` будет нужен для создания события изменения определенного поля ввода, в контексте проектной изменения могут быть в объектах типа TUserContact или TUserPayAddress
- `render(data: Partial<T> & {valid: boolean; errors: string[]})` метод будет нужен для рендера формы, для рендера потребуется учесть не только то, в каких полях пользователь будет вводить данные, но и информацию об ошибках заполнения формы, если они будут, и состояния кнопки отправки формы.

#### Класс Basket
Класс будет использован для отображения корзины с товарами в модальном окне. На вход в конструктор должен передаваться HTML-элемент, который будет выполнять роль контейнера и объект событий, записываться они будут в поля `container: HTMLElement` и `events: EventEmitter`, соответственно. Поля класса:
- `protected _list: HTMLElement` будет хранить элемент списка, в котором будет выводиться список товаров, добавленных в корзину
- `protected _total: HTMLElement` будет хранить элемент строки, в которой будет выводиться общая стоимость товаров в корзине
- `protected _button: HTMLButtonElement` будет хранить элемент кнопки, по нажатию на которую для пользователя должна начинаться будет процедура оформления покупки
- `items: HTMLElement[]` значение поля будет устанавливаться через сеттер, в результате работы которого элементы карточек товаров будут добавляться в список
- `total: number` поле для хранения общей стоимости корзины, для него будет сеттер, аналогичный по логике сеттеру для items

#### Класс OrderSuccess
Класс будет использован для отображения уведомления об успешно отправленном заказе внутри модального окна, в конструктор класса будет передаваться родительский элемент-контейнер для содержимого и объект событий, в контексте проектной достаточно, чтобы объект событий был типизирован как `{onClick: () => void;}`, так как контент такого окна будет содержать только кнопку подтверждения, соответственно в классе будет поле `protected _close: HTMLElement`, содержащее элемент кнопки подтверждения, которая будет закрывать это модальное окно.

### Слой презентера
Связь между слоями отображения и модели будет реализована через слой презентера. В презентере будет реализована бизнес-логика, нужно будет ловить события и либо менять данные в модели, либо менять что-то в отображении, либо и то, и другое.   
При первичной загрузке страницы необходимо получать с сервера список карточек товаров и отображать их на странице.  
Какие события могут происходить в программе и на них надо реагировать:
- Открытие или закрытие модального любого модального окна должно вести к блокировке или разблокировке скролла главной странциы. Предварительное имя событий: modal:open и modal:close.
- При клике по карточке товара будет происходить событие card:select, чтобы было проще отследить, какую карточку кликнули.
- Изменение количества товаров в корзине. Предварительное имя события: basket:change.
- Изменение статуса валидации формы. Предварительное имя события: formValidation:change (formPayAddressValidation:change, formContactValidation:change, formBasketValidation:change).
- Изменение поля ввода в форме. Предварительное имя событий: address:change, email:change, phone:change.
- Изменение способа оплаты. Предварительное имя события: payment:change.
- Отправка формы с информацией о заказе на сервер помимо непосредственной отправки информации на сервер должна приводить к очистке корзины. Предварительное имя события: order:open.
- Изменение списка карточек-товаров cards:change.